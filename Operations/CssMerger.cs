using CssClassUtility.Models;
using System.Text;

namespace CssClassUtility.Operations;

/// <summary>
/// CSS Class 合併工具
/// </summary>
public static class CssMerger
{
    /// <summary>
    /// 批次合併多個 CSS 檔案到目標檔案
    /// </summary>
    public static string BatchMerge(
        IEnumerable<string> sourcePaths,
        string targetPath,
        MergeStrategy strategy)
    {
        if (!File.Exists(targetPath))
        {
            // 如果目標不存在，建立空檔案
            File.WriteAllText(targetPath, "/* Generated by CssClassutility */\n");
        }

        var sb = new StringBuilder();
        int mergedCount = 0;
        int addedCount = 0;

        foreach (var sourcePath in sourcePaths)
        {
            if (!File.Exists(sourcePath)) continue;

            var sourceClasses = CssParser.GetClasses(sourcePath);
            
            // 為了避免頻繁讀寫目標檔案，我們先讀取一次目標檔案的類別結構
            // 但因為我們可能會新增類別，所以每次處理一個來源檔案後，最好重新讀取目標
            // 簡單起見，我們對每個來源檔案處理完後，寫入一次目標檔案。
            
            // 讀取目標檔案現有類別
            var targetClasses = CssParser.GetClasses(targetPath);
            var targetClassMap = targetClasses
                .GroupBy(c => c.ClassName)
                // 若有重複，簡單起見取第一個
                .ToDictionary(g => g.Key, g => g.First());

            // var targetContent = File.ReadAllText(targetPath); // Unused currently in this logic

            foreach (var sourceClass in sourceClasses)
            {
                if (targetClassMap.TryGetValue(sourceClass.ClassName, out var targetClass))
                {
                    // 合併邏輯
                    var sourceProps = CssParser.ContentToPropertiesPublic(sourceClass.Content);
                    var targetProps = CssParser.ContentToPropertiesPublic(targetClass.Content);
                    bool propsChanged = false;

                    switch (strategy)
                    {
                        case MergeStrategy.Overwrite:
                            foreach (var kvp in sourceProps)
                            {
                                if (!targetProps.ContainsKey(kvp.Key) || targetProps[kvp.Key] != kvp.Value)
                                {
                                    targetProps[kvp.Key] = kvp.Value;
                                    propsChanged = true;
                                }
                            }
                            break;

                        case MergeStrategy.FillMissing:
                            foreach (var kvp in sourceProps)
                            {
                                if (!targetProps.ContainsKey(kvp.Key))
                                {
                                    targetProps[kvp.Key] = kvp.Value;
                                    propsChanged = true;
                                }
                            }
                            break;
                            
                        // PruneDuplicate 暫時略過
                    }

                    if (propsChanged)
                    {
                        // 更新目標類別內容
                        // 使用 ReplaceBlockPublic
                        string newContent = CssParser.PropertiesToContentPublic(targetProps, targetClass.Selector);
                        CssParser.ReplaceBlockPublic(targetPath, targetClass.StartIndex, targetClass.BlockEnd, newContent);
                        
                        // 為了確保索引正確，每次修改後重新讀取
                        // 這會比較慢，但確保正確性
                        targetClasses = CssParser.GetClasses(targetPath);
                        targetClassMap = targetClasses
                            .GroupBy(c => c.ClassName)
                            .ToDictionary(g => g.Key, g => g.First());

                        mergedCount++;
                    }
                }
                else
                {
                    // 新增類別
                    // 直接 Append 到檔案末尾
                    string newBlock = $"\n{sourceClass.Selector} {{\n{sourceClass.Content}\n}}";
                    File.AppendAllText(targetPath, newBlock);
                    addedCount++;
                    
                    // 新增後也要更新 Map，以便後續同名類別能合併
                    targetClasses = CssParser.GetClasses(targetPath);
                    targetClassMap = targetClasses
                        .GroupBy(c => c.ClassName)
                        .ToDictionary(g => g.Key, g => g.First());
                }
            }
        }

        return $"合併完成。更新了 {mergedCount} 個類別，新增了 {addedCount} 個類別。";
    }

    public static string BatchMerge(
        string sourcePathsFile,
        string targetPath,
        MergeStrategy strategy)
    {
        if (!File.Exists(sourcePathsFile))
        {
            throw new FileNotFoundException("Source paths file not found", sourcePathsFile);
        }

        string content = File.ReadAllText(sourcePathsFile);
        IEnumerable<string> paths;

        if (content.TrimStart().StartsWith("["))
        {
            // Try JSON
            try
            {
                paths = System.Text.Json.JsonSerializer.Deserialize<string[]>(content) ?? Array.Empty<string>();
            }
            catch
            {
                paths = File.ReadLines(sourcePathsFile);
            }
        }
        else
        {
            paths = File.ReadLines(sourcePathsFile);
        }

        return BatchMerge(paths.Where(p => !string.IsNullOrWhiteSpace(p)), targetPath, strategy);
    }

    /// <summary>
    /// 合併 CSS Class（從 JSON 實體或另一個檔案）
    /// </summary>
    public static string MergeCssClass(
        string targetPath,
        string targetClassName,
        string sourceObject,
        MergeStrategy strategy = MergeStrategy.Overwrite,
        int targetIndex = 0)
    {
        // sourceObject 格式：
        // 1. JSON 字串 (以 { 開頭)
        // 2. 檔案路徑:.className 格式

        CssEntity sourceEntity;

        if (sourceObject.TrimStart().StartsWith("{"))
        {
            // JSON 格式
            sourceEntity = System.Text.Json.JsonSerializer.Deserialize<CssEntity>(sourceObject)
                ?? throw new Exception("無法解析來源 JSON");
        }
        else
        {
            // 檔案格式：path:.className
            var match = System.Text.RegularExpressions.Regex.Match(sourceObject, @"(.+\\.css):\\.?(.+)");
            if (!match.Success)
                throw new ArgumentException("來源格式錯誤，應為 'path:.className' 或 JSON");

            string sourcePath = match.Groups[1].Value;
            string sourceClassName = match.Groups[2].Value;

            var sourceClasses = CssParser.GetClasses(sourcePath)
                .Where(c => c.ClassName.Equals(sourceClassName, StringComparison.OrdinalIgnoreCase))
                .ToList();

            if (sourceClasses.Count == 0)
                throw new Exception($"來源檔案中找不到 Class .{sourceClassName}");

            var sourceClass = sourceClasses[0];
            sourceEntity = new CssEntity
            {
                Name = sourceClassName,
                Selector = sourceClass.Selector,
                Properties = new System.Collections.Generic.SortedDictionary<string, string>(
                    CssParser.ContentToPropertiesPublic(sourceClass.Content))
            };
        }

        // 取得目標 Class
        var targetClasses = CssParser.GetClasses(targetPath)
            .Where(c => c.ClassName.Equals(targetClassName, StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (targetClasses.Count == 0)
            throw new Exception($"目標檔案中找不到 Class .{targetClassName}");

        if (targetIndex >= targetClasses.Count)
            throw new Exception($"索引 {targetIndex} 超出範圍");

        var target = targetClasses[targetIndex];
        var targetProps = CssParser.ContentToPropertiesPublic(target.Content);

        // 根據策略合併
        switch (strategy)
        {
            case MergeStrategy.Overwrite:
                foreach (var kvp in sourceEntity.Properties)
                    targetProps[kvp.Key] = kvp.Value;
                break;

            case MergeStrategy.FillMissing:
                foreach (var kvp in sourceEntity.Properties)
                    if (!targetProps.ContainsKey(kvp.Key))
                        targetProps[kvp.Key] = kvp.Value;
                break;

            case MergeStrategy.PruneDuplicate:
                foreach (var kvp in sourceEntity.Properties.ToList())
                    if (targetProps.ContainsKey(kvp.Key) && targetProps[kvp.Key] == kvp.Value)
                        targetProps.Remove(kvp.Key);
                break;
        }

        // 寫回
        string newContent = CssParser.PropertiesToContentPublic(targetProps, target.Selector);
        CssParser.ReplaceBlockPublic(targetPath, target.StartIndex, target.BlockEnd, newContent);

        return $"已合併到 Class .{targetClassName} (策略: {strategy})";
    }
}
